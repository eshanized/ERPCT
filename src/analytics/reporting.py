#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Report generation module for ERPCT.
This module provides reporting capabilities for attack results.
"""

import os
import json
import datetime
import time
from typing import Dict, List, Tuple, Any, Optional, Union, Set, Callable
from enum import Enum, auto
from dataclasses import dataclass, field

from src.utils.logging import get_logger
from src.analytics.statistics import AttackStatistics
from src.analytics.visualization import (
    create_attack_timeline, 
    create_success_rate_chart,
    create_performance_graph,
    create_resource_usage_charts
)

try:
    import markdown
    MARKDOWN_AVAILABLE = True
except ImportError:
    MARKDOWN_AVAILABLE = False

try:
    import weasyprint
    PDF_AVAILABLE = True
except ImportError:
    PDF_AVAILABLE = False


class ReportFormat(Enum):
    """Supported report formats."""
    
    TEXT = auto()
    HTML = auto()
    JSON = auto()
    PDF = auto()
    MARKDOWN = auto()


@dataclass
class ReportSection:
    """Class representing a section in a report."""
    
    title: str
    content: str
    order: int = 0
    subsections: List['ReportSection'] = field(default_factory=list)
    data: Dict[str, Any] = field(default_factory=dict)
    chart_path: Optional[str] = None
    
    def add_subsection(self, section: 'ReportSection') -> None:
        """Add a subsection to this section.
        
        Args:
            section: Section to add
        """
        self.subsections.append(section)
        # Sort subsections by order
        self.subsections.sort(key=lambda x: x.order)


@dataclass
class Report:
    """Class representing a complete report."""
    
    title: str
    timestamp: float = field(default_factory=time.time)
    description: str = ""
    sections: List[ReportSection] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)
    output_dir: str = ""
    chart_dir: str = ""
    
    def add_section(self, section: ReportSection) -> None:
        """Add a section to the report.
        
        Args:
            section: Section to add
        """
        self.sections.append(section)
        # Sort sections by order
        self.sections.sort(key=lambda x: x.order)
    
    def get_section(self, title: str) -> Optional[ReportSection]:
        """Get a section by title.
        
        Args:
            title: Section title to find
            
        Returns:
            Section if found, None otherwise
        """
        for section in self.sections:
            if section.title == title:
                return section
        return None


def generate_report(attack_data: Dict[str, Any], 
                  format: ReportFormat = ReportFormat.HTML,
                  output_path: Optional[str] = None,
                  include_charts: bool = True) -> Union[str, bytes, Dict[str, Any]]:
    """Generate a report from attack data.
    
    Args:
        attack_data: Dictionary with attack data
        format: Output format
        output_path: Optional output path
        include_charts: Whether to include charts
        
    Returns:
        Report content in the requested format
    """
    logger = get_logger(__name__)
    
    # Create base report object
    report = Report(
        title=f"Attack Report: {attack_data.get('protocol', 'Unknown')} - {attack_data.get('target', 'Unknown')}",
        description="Password cracking attack report generated by ERPCT",
        metadata={
            "timestamp": datetime.datetime.now().isoformat(),
            "erpct_version": attack_data.get("version", "unknown"),
            "protocol": attack_data.get("protocol", "unknown"),
            "target": attack_data.get("target", "unknown")
        }
    )
    
    # Create output directories if needed
    if output_path:
        report.output_dir = os.path.dirname(os.path.abspath(output_path))
        report.chart_dir = os.path.join(report.output_dir, "charts")
        
        if include_charts and not os.path.exists(report.chart_dir):
            try:
                os.makedirs(report.chart_dir, exist_ok=True)
            except Exception as e:
                logger.warning(f"Failed to create chart directory: {str(e)}")
                include_charts = False
    
    # Create report sections
    _create_summary_section(report, attack_data)
    _create_statistics_section(report, attack_data)
    _create_credentials_section(report, attack_data)
    
    if include_charts:
        _create_visualization_section(report, attack_data)
    
    # Include performance recommendations if available
    if "recommendations" in attack_data:
        _create_recommendations_section(report, attack_data)
    
    # Export in requested format
    if format == ReportFormat.TEXT:
        return _export_text(report)
    elif format == ReportFormat.HTML:
        return _export_html(report)
    elif format == ReportFormat.JSON:
        return _export_json(report)
    elif format == ReportFormat.PDF:
        return _export_pdf(report)
    elif format == ReportFormat.MARKDOWN:
        return _export_markdown(report)
    else:
        logger.warning(f"Unsupported report format: {format}")
        return _export_text(report)  # Default to text


def _create_summary_section(report: Report, attack_data: Dict[str, Any]) -> None:
    """Create summary section of the report.
    
    Args:
        report: Report object to update
        attack_data: Attack data dictionary
    """
    # Extract key metrics
    protocol = attack_data.get("protocol", "unknown")
    target = attack_data.get("target", "unknown")
    duration = attack_data.get("duration", 0)
    total_attempts = attack_data.get("total_attempts", 0)
    successful_attempts = attack_data.get("successful_attempts", 0)
    success_rate = (successful_attempts / total_attempts * 100) if total_attempts > 0 else 0
    
    # Format duration
    duration_str = str(datetime.timedelta(seconds=int(duration)))
    
    # Create summary content
    summary_content = (
        f"Attack against {target} using {protocol} protocol.\n"
        f"Duration: {duration_str}\n"
        f"Total attempts: {total_attempts:,}\n"
        f"Successful attempts: {successful_attempts:,}\n"
        f"Success rate: {success_rate:.2f}%\n"
    )
    
    # Add thread information if available
    if "threads" in attack_data:
        summary_content += f"Thread count: {attack_data['threads']}\n"
    
    # Add timestamp information
    if "timestamp" in attack_data:
        timestamp = datetime.datetime.fromtimestamp(attack_data["timestamp"])
        summary_content += f"Start time: {timestamp.strftime('%Y-%m-%d %H:%M:%S')}\n"
    
    # Create and add section
    summary_section = ReportSection(
        title="Summary",
        content=summary_content,
        order=1,
        data={
            "protocol": protocol,
            "target": target,
            "duration": duration,
            "total_attempts": total_attempts,
            "successful_attempts": successful_attempts,
            "success_rate": success_rate
        }
    )
    
    report.add_section(summary_section)


def _create_statistics_section(report: Report, attack_data: Dict[str, Any]) -> None:
    """Create statistics section of the report.
    
    Args:
        report: Report object to update
        attack_data: Attack data dictionary
    """
    # Extract statistics
    total_attempts = attack_data.get("total_attempts", 0)
    completed_attempts = attack_data.get("completed_attempts", 0)
    successful_attempts = attack_data.get("successful_attempts", 0)
    duration = attack_data.get("duration", 0)
    
    # Calculate derived statistics
    attempts_per_second = total_attempts / duration if duration > 0 else 0
    completion_rate = (completed_attempts / total_attempts * 100) if total_attempts > 0 else 0
    success_rate = (successful_attempts / completed_attempts * 100) if completed_attempts > 0 else 0
    
    # Create statistics content
    statistics_content = (
        f"Performance statistics:\n"
        f"Attempts per second: {attempts_per_second:.2f}\n"
        f"Completion rate: {completion_rate:.2f}%\n"
        f"Success rate: {success_rate:.2f}%\n"
    )
    
    # Add resource usage if available
    if "cpu_usage" in attack_data or "memory_usage" in attack_data:
        statistics_content += "\nResource usage:\n"
        
        if "cpu_usage" in attack_data:
            statistics_content += f"CPU usage: {attack_data['cpu_usage']:.1f}%\n"
            
        if "memory_usage" in attack_data:
            statistics_content += f"Memory usage: {attack_data['memory_usage']:.1f} MB\n"
    
    # Create and add section
    statistics_section = ReportSection(
        title="Statistics",
        content=statistics_content,
        order=2,
        data={
            "attempts_per_second": attempts_per_second,
            "completion_rate": completion_rate,
            "success_rate": success_rate,
            "cpu_usage": attack_data.get("cpu_usage", 0),
            "memory_usage": attack_data.get("memory_usage", 0)
        }
    )
    
    report.add_section(statistics_section)


def _create_credentials_section(report: Report, attack_data: Dict[str, Any]) -> None:
    """Create credentials section of the report.
    
    Args:
        report: Report object to update
        attack_data: Attack data dictionary
    """
    # Extract credentials
    credentials = attack_data.get("credentials", [])
    
    if not credentials:
        # No credentials found
        credentials_content = "No valid credentials were found."
    else:
        # Format credentials list
        credentials_content = "Valid credentials discovered:\n\n"
        
        for i, cred in enumerate(credentials, 1):
            username = cred.get("username", "")
            password = cred.get("password", "")
            timestamp = cred.get("timestamp", 0)
            
            # Format timestamp if available
            timestamp_str = ""
            if timestamp:
                try:
                    dt = datetime.datetime.fromtimestamp(timestamp)
                    timestamp_str = f" (discovered at {dt.strftime('%Y-%m-%d %H:%M:%S')})"
                except (ValueError, TypeError):
                    pass
                
            credentials_content += f"{i}. {username}:{password}{timestamp_str}\n"
    
    # Create and add section
    credentials_section = ReportSection(
        title="Credentials",
        content=credentials_content,
        order=3,
        data={
            "credentials_count": len(credentials),
            "credentials": credentials
        }
    )
    
    report.add_section(credentials_section)


def _create_visualization_section(report: Report, attack_data: Dict[str, Any]) -> None:
    """Create visualization section of the report.
    
    Args:
        report: Report object to update
        attack_data: Attack data dictionary
    """
    # Get logger
    logger = get_logger(__name__)
    
    # Skip if chart directory isn't available
    if not report.chart_dir:
        return
    
    # Extract time series data if available
    timestamps = attack_data.get("timestamps", [])
    success_counts = attack_data.get("success_counts", [])
    failure_counts = attack_data.get("failure_counts", [])
    
    has_time_series = timestamps and (success_counts or failure_counts) and len(timestamps) > 1
    
    # Create visualization content
    visualization_content = "Visualizations of the attack data:\n\n"
    
    # Create attack timeline chart if time series data is available
    if has_time_series and len(timestamps) == len(success_counts) and len(timestamps) == len(failure_counts):
        # Create the visualization
        timeline_path = os.path.join(report.chart_dir, "attack_timeline.png")
        
        try:
            # Ensure success and failure counts are same length as timestamps
            if len(success_counts) < len(timestamps):
                success_counts.extend([success_counts[-1]] * (len(timestamps) - len(success_counts)))
            if len(failure_counts) < len(timestamps):
                failure_counts.extend([failure_counts[-1]] * (len(timestamps) - len(failure_counts)))
            
            create_attack_timeline(
                timestamps=timestamps,
                successes=success_counts,
                failures=failure_counts,
                title="Attack Timeline",
                output_path=timeline_path
            )
            
            visualization_content += f"- Attack timeline chart saved to {os.path.basename(timeline_path)}\n"
            
            # Add chart path to section data for HTML/PDF rendering
            timeline_section = ReportSection(
                title="Attack Timeline",
                content="Timeline showing the progress of the attack over time.",
                order=1,
                chart_path=timeline_path
            )
        except Exception as e:
            logger.error(f"Failed to create timeline chart: {str(e)}")
    
    # Extract resource usage data if available
    cpu_data = attack_data.get("cpu_samples", [])
    memory_data = attack_data.get("memory_samples", [])
    
    # Create resource usage chart if data is available
    if cpu_data and memory_data and timestamps and len(cpu_data) == len(memory_data) == len(timestamps):
        # Create the visualization
        resource_path = os.path.join(report.chart_dir, "resource_usage.png")
        
        try:
            create_resource_usage_charts(
                cpu_data=cpu_data,
                memory_data=memory_data,
                timestamps=timestamps,
                title="Resource Usage",
                output_path=resource_path
            )
            
            visualization_content += f"- Resource usage chart saved to {os.path.basename(resource_path)}\n"
            
            # Add chart path to section data for HTML/PDF rendering
            resource_section = ReportSection(
                title="Resource Usage",
                content="CPU and memory usage during the attack.",
                order=2,
                chart_path=resource_path
            )
        except Exception as e:
            logger.error(f"Failed to create resource usage chart: {str(e)}")
    
    # Create and add section if we have content
    if visualization_content != "Visualizations of the attack data:\n\n":
        visualization_section = ReportSection(
            title="Visualizations",
            content=visualization_content,
            order=4
        )
        
        # Add subsections if we created them
        if 'timeline_section' in locals():
            visualization_section.add_subsection(timeline_section)
            
        if 'resource_section' in locals():
            visualization_section.add_subsection(resource_section)
            
        report.add_section(visualization_section)


def _create_recommendations_section(report: Report, attack_data: Dict[str, Any]) -> None:
    """Create recommendations section of the report.
    
    Args:
        report: Report object to update
        attack_data: Attack data dictionary
    """
    # Extract recommendations
    recommendations = attack_data.get("recommendations", [])
    
    if not recommendations:
        return
    
    # Format recommendations
    recommendations_content = "Optimization recommendations:\n\n"
    
    for i, rec in enumerate(recommendations, 1):
        title = rec.get("title", "")
        description = rec.get("description", "")
        impact = rec.get("impact", "")
        actions = rec.get("actions", [])
        
        recommendations_content += f"{i}. {title} (Impact: {impact.upper()})\n"
        recommendations_content += f"   {description}\n"
        recommendations_content += "   Recommended actions:\n"
        
        for j, action in enumerate(actions, 1):
            recommendations_content += f"   - {action}\n"
        
        recommendations_content += "\n"
    
    # Create and add section
    recommendations_section = ReportSection(
        title="Recommendations",
        content=recommendations_content,
        order=5,
        data={
            "recommendations": recommendations
        }
    )
    
    report.add_section(recommendations_section)


def _export_text(report: Report) -> str:
    """Export report as plain text.
    
    Args:
        report: Report object
        
    Returns:
        Text representation of the report
    """
    # Get logger
    logger = get_logger(__name__)
    
    lines = []
    
    # Add title and description
    lines.append(report.title)
    lines.append("=" * len(report.title))
    lines.append("")
    
    if report.description:
        lines.append(report.description)
        lines.append("")
    
    # Add timestamp
    dt = datetime.datetime.fromtimestamp(report.timestamp)
    lines.append(f"Generated: {dt.strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append("")
    
    # Add sections
    for section in report.sections:
        lines.append(section.title)
        lines.append("-" * len(section.title))
        lines.append("")
        lines.append(section.content)
        lines.append("")
        
        # Add subsections
        for subsection in section.subsections:
            lines.append(f"### {subsection.title}")
            lines.append("")
            lines.append(subsection.content)
            lines.append("")
            
            # Note about charts
            if subsection.chart_path:
                lines.append(f"Chart: {os.path.basename(subsection.chart_path)}")
                lines.append("")
    
    return "\n".join(lines)


def _export_html(report: Report) -> str:
    """Export report as HTML.
    
    Args:
        report: Report object
        
    Returns:
        HTML representation of the report
    """
    # Get logger
    logger = get_logger(__name__)
    
    html = []
    
    # HTML header
    html.append("<!DOCTYPE html>")
    html.append("<html lang=\"en\">")
    html.append("<head>")
    html.append("    <meta charset=\"UTF-8\">")
    html.append("    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">")
    html.append(f"    <title>{report.title}</title>")
    html.append("    <style>")
    html.append("        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 20px; color: #333; }")
    html.append("        h1 { color: #2c3e50; }")
    html.append("        h2 { color: #3498db; margin-top: 30px; border-bottom: 1px solid #eee; padding-bottom: 5px; }")
    html.append("        h3 { color: #2980b9; }")
    html.append("        pre { background-color: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; }")
    html.append("        .container { max-width: 1200px; margin: 0 auto; }")
    html.append("        .visualization { margin: 20px 0; text-align: center; }")
    html.append("        .visualization img { max-width: 100%; border: 1px solid #ddd; border-radius: 5px; }")
    html.append("        .metadata { font-size: 0.9em; color: #666; margin-bottom: 20px; }")
    html.append("        .recommendation { margin-bottom: 20px; padding: 10px; border-left: 4px solid #3498db; background-color: #ecf0f1; }")
    html.append("        .high { border-color: #e74c3c; }")
    html.append("        .medium { border-color: #f39c12; }")
    html.append("        .low { border-color: #2ecc71; }")
    html.append("    </style>")
    html.append("</head>")
    html.append("<body>")
    html.append("    <div class=\"container\">")
    
    # Report header
    html.append(f"        <h1>{report.title}</h1>")
    if report.description:
        html.append(f"        <p>{report.description}</p>")
    
    # Metadata
    html.append("        <div class=\"metadata\">")
    dt = datetime.datetime.fromtimestamp(report.timestamp)
    html.append(f"            <p>Generated: {dt.strftime('%Y-%m-%d %H:%M:%S')}</p>")
    
    # Add protocol and target if available
    if "protocol" in report.metadata and "target" in report.metadata:
        protocol = report.metadata["protocol"]
        target = report.metadata["target"]
        html.append(f"            <p>Protocol: {protocol}</p>")
        html.append(f"            <p>Target: {target}</p>")
    
    html.append("        </div>")
    
    # Sections
    for section in report.sections:
        html.append(f"        <h2>{section.title}</h2>")
        
        # Format content as preformatted text
        html.append("        <pre>")
        html.append(section.content)
        html.append("        </pre>")
        
        # Add subsections
        for subsection in section.subsections:
            html.append(f"        <h3>{subsection.title}</h3>")
            html.append(f"        <p>{subsection.content}</p>")
            
            # Add chart if available
            if subsection.chart_path:
                chart_filename = os.path.basename(subsection.chart_path)
                html.append("        <div class=\"visualization\">")
                html.append(f"            <img src=\"charts/{chart_filename}\" alt=\"{subsection.title}\">")
                html.append("        </div>")
    
    # HTML footer
    html.append("    </div>")
    html.append("</body>")
    html.append("</html>")
    
    return "\n".join(html)


def _export_json(report: Report) -> Dict[str, Any]:
    """Export report as JSON.
    
    Args:
        report: Report object
        
    Returns:
        JSON-serializable dictionary representation of the report
    """
    # Get logger
    logger = get_logger(__name__)
    
    # Convert to JSON-serializable structure
    result = {
        "title": report.title,
        "description": report.description,
        "timestamp": report.timestamp,
        "metadata": report.metadata,
        "sections": []
    }
    
    # Convert sections
    for section in report.sections:
        section_dict = {
            "title": section.title,
            "content": section.content,
            "order": section.order,
            "data": section.data,
            "chart_path": section.chart_path,
            "subsections": []
        }
        
        # Convert subsections
        for subsection in section.subsections:
            subsection_dict = {
                "title": subsection.title,
                "content": subsection.content,
                "order": subsection.order,
                "data": subsection.data,
                "chart_path": subsection.chart_path
            }
            
            section_dict["subsections"].append(subsection_dict)
            
        result["sections"].append(section_dict)
    
    return result


def _export_markdown(report: Report) -> str:
    """Export report as Markdown.
    
    Args:
        report: Report object
        
    Returns:
        Markdown representation of the report
    """
    # Get logger
    logger = get_logger(__name__)
    
    md = []
    
    # Title and description
    md.append(f"# {report.title}")
    md.append("")
    
    if report.description:
        md.append(report.description)
        md.append("")
    
    # Metadata
    dt = datetime.datetime.fromtimestamp(report.timestamp)
    md.append(f"*Generated: {dt.strftime('%Y-%m-%d %H:%M:%S')}*")
    md.append("")
    
    # Add protocol and target if available
    if "protocol" in report.metadata and "target" in report.metadata:
        protocol = report.metadata["protocol"]
        target = report.metadata["target"]
        md.append(f"- **Protocol:** {protocol}")
        md.append(f"- **Target:** {target}")
        md.append("")
    
    # Sections
    for section in report.sections:
        md.append(f"## {section.title}")
        md.append("")
        
        # Format content as code block for some sections
        if section.title in ["Summary", "Statistics", "Credentials"]:
            md.append("```")
            md.append(section.content)
            md.append("```")
        else:
            md.append(section.content)
            
        md.append("")
        
        # Add subsections
        for subsection in section.subsections:
            md.append(f"### {subsection.title}")
            md.append("")
            md.append(subsection.content)
            md.append("")
            
            # Add chart if available
            if subsection.chart_path:
                chart_filename = os.path.basename(subsection.chart_path)
                md.append(f"![{subsection.title}](charts/{chart_filename})")
                md.append("")
    
    return "\n".join(md)


def _export_pdf(report: Report) -> bytes:
    """Export report as PDF.
    
    Args:
        report: Report object
        
    Returns:
        PDF document as bytes
    """
    # Get logger
    logger = get_logger(__name__)
    
    # Check if PDF generation is available
    if not PDF_AVAILABLE:
        logger.warning("PDF export requires WeasyPrint package")
        # Return HTML content as fallback
        return _export_html(report).encode('utf-8')
    
    try:
        # Generate HTML then convert to PDF
        html_content = _export_html(report)
        pdf_document = weasyprint.HTML(string=html_content, base_url=report.output_dir).render()
        
        # Return PDF as bytes
        return pdf_document.write_pdf()
    except Exception as e:
        logger.error(f"Error generating PDF: {str(e)}")
        # Return HTML content as fallback
        return _export_html(report).encode('utf-8')


def export_to_pdf(report_data: Dict[str, Any], output_path: str) -> bool:
    """Export attack report to PDF.
    
    Args:
        report_data: Dictionary with attack data
        output_path: Path to save the PDF report
        
    Returns:
        True if successful, False otherwise
    """
    logger = get_logger(__name__)
    
    try:
        # Generate report in PDF format
        pdf_content = generate_report(
            attack_data=report_data,
            format=ReportFormat.PDF,
            output_path=output_path,
            include_charts=True
        )
        
        # Write to file
        with open(output_path, 'wb') as f:
            f.write(pdf_content)
            
        logger.info(f"Exported PDF report to {output_path}")
        return True
    except Exception as e:
        logger.error(f"Failed to export PDF report: {str(e)}")
        return False


def export_to_html(report_data: Dict[str, Any], output_path: str) -> bool:
    """Export attack report to HTML.
    
    Args:
        report_data: Dictionary with attack data
        output_path: Path to save the HTML report
        
    Returns:
        True if successful, False otherwise
    """
    logger = get_logger(__name__)
    
    try:
        # Generate report in HTML format
        html_content = generate_report(
            attack_data=report_data,
            format=ReportFormat.HTML,
            output_path=output_path,
            include_charts=True
        )
        
        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
            
        logger.info(f"Exported HTML report to {output_path}")
        return True
    except Exception as e:
        logger.error(f"Failed to export HTML report: {str(e)}")
        return False


def export_to_json(report_data: Dict[str, Any], output_path: str) -> bool:
    """Export attack report to JSON.
    
    Args:
        report_data: Dictionary with attack data
        output_path: Path to save the JSON report
        
    Returns:
        True if successful, False otherwise
    """
    logger = get_logger(__name__)
    
    try:
        # Generate report in JSON format
        json_content = generate_report(
            attack_data=report_data,
            format=ReportFormat.JSON,
            output_path=None,  # No charts for JSON
            include_charts=False
        )
        
        # Write to file
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(json_content, f, indent=2)
            
        logger.info(f"Exported JSON report to {output_path}")
        return True
    except Exception as e:
        logger.error(f"Failed to export JSON report: {str(e)}")
        return False
